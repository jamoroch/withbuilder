/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package co.xapuka.withbuilder;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static javax.lang.model.element.ElementKind.*;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.STATIC;

public class WithBuilderProcessor extends AbstractProcessor {
    public boolean someLibraryMethod() {
        return true;
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations == null || annotations.isEmpty()) {
            return false;
        }

        Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(WithBuilder.class);
        if(annotatedElements != null && !annotatedElements.isEmpty()) {
            pm("Processing WithBuilder...");
        }
        for(Element annotatedElement: annotatedElements) {
            final List<? extends Element> enclosedElements = annotatedElement.getEnclosedElements();

            final WithBuilder annotation = annotatedElement.getAnnotation(WithBuilder.class);
            if(annotation.debug()) {
                return debug(enclosedElements);
            }

            Map<Boolean, List<Element>> partition = enclosedElements.stream().collect(Collectors.partitioningBy(this::onlyInstanceFields));
            Map<String, String> fieldsAndTheirTypes =
                    partition.get(true).stream().collect(Collectors.toMap(e -> e.getSimpleName().toString(), e -> e.asType().toString()));

            boolean didValidate = validateSetters(partition.get(false).stream(), fieldsAndTheirTypes, annotatedElement);

            if(!didValidate) {
                return true;
            }

            ClassAndPackageName classAndPackageName = extractClassAndPackageName(annotatedElement, annotation);
            if(classAndPackageName == null) {
                return reportError("No default constructor found!", annotatedElement);
            }

            try {
                writeFile(classAndPackageName, fieldsAndTheirTypes);
            } catch (IOException e) {
                return reportError(e.getMessage(), annotatedElement);
            };
        }
        return false;
    }

    private ClassAndPackageName extractClassAndPackageName(Element annotatedElement, WithBuilder annotation){

        TypeElement typeElement = getTypeElement(annotatedElement);
        if(typeElement == null) {
          return null;
        }

        return DefaultClassAndPackageName.from(typeElement, annotation.suffix());
    }
    private boolean debug(List<? extends Element> enclosedElements) {
        pm("In Debugging");
        enclosedElements.forEach(el -> {
            pm(el.getSimpleName() + ":" + el.asType() + ":" +el.asType().getKind());
            if(el instanceof ExecutableElement) {
                pm("ExecutableElement: " + ((ExecutableElement)el).getSimpleName().toString());
            }
        });
        return false;
    }

    private boolean validateSetters(Stream<Element> noFields, Map<String, String> fieldsAndTheirTypes, Element annotatedElement) {
        List<Element> setters = noFields.collect(Collectors.partitioningBy(this::onlySetter)).get(true);

        Collection<String> onlyFieldNames = new ArrayList<>(fieldsAndTheirTypes.keySet());

        List<String> settersNames = setters.stream().map(Element::getSimpleName).map(Name::toString).collect(Collectors.toList());
        for (String fieldName: fieldsAndTheirTypes.keySet()) {
            String setterName = "set"+BuilderClassGenerator.capitalize(fieldName);

            if(settersNames.stream().filter(n -> n.equals(setterName)).count() != 0) {
                onlyFieldNames.remove(fieldName);
            }
        }
        onlyFieldNames.stream().forEach( n -> reportError("No setter found for field " + n , annotatedElement));

        if(onlyFieldNames.size() != 0) {
            return false;
        }

        return true;
    }

    private  boolean onlySetter(Element element) {
        if(!(element instanceof ExecutableElement)) {
            return false;
        }
        ExecutableElement executableElement = (ExecutableElement) element;
        if(executableElement.getParameters().size() != 1) {
            return false;
        }
        if(executableElement.getReturnType().getKind() != TypeKind.VOID) {
            return false;
        }
        if(!executableElement.getSimpleName().toString().matches("^set.*")){
            return false;
        }
        return true;
    }

    private boolean onlyInstanceFields(Element e) {
        return (FIELD == e.getKind() ) &&
                e.getModifiers().stream().filter(m -> (FINAL == m || STATIC == m)).count() == 0;
    }

    private synchronized void writeFile(ClassAndPackageName classAndPackageName, Map<String, String> fieldsAndTheirTypes) throws IOException {

        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(classAndPackageName.getPackageName() + "." + classAndPackageName.getBuilderClassName());
        try (PrintWriter pw = new PrintWriter(builderFile.openWriter())) {
            BuilderClassGenerator generator = new BuilderClassGenerator(classAndPackageName, fieldsAndTheirTypes, pw);

            generator.writeInit();
            generator.writeMutators();
            generator.withBuildMethod();
            generator.writePrivateDefaultConstructor();
            generator.writeFields();
            generator.writeEnd();
        }
    }


    private TypeElement getTypeElement(Element element) {
        TypeElement typeElement = element.getEnclosedElements()
                .stream()
                .filter(e -> CONSTRUCTOR == e.getKind())
                .map(e -> e.getEnclosingElement())
                .map(e -> (TypeElement) e)
                .reduce((x, y) -> x)
                .orElseGet(() -> null);
        return typeElement;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(WithBuilder.class.getName());
    }

    private void pm(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
    }

    private boolean reportError (String message, Element element) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
        return true;
    }
}
