/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package co.xapuka.withbuilder;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static javax.lang.model.element.ElementKind.*;

public class WithBuilderProcessor extends AbstractProcessor {
    public boolean someLibraryMethod() {
        return true;
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations == null || annotations.isEmpty()) {
            return false;
        }
        pm("Processing WithBuilder...");

        Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotations.iterator().next());
        annotatedElements.forEach(ann -> {

            TypeElement typeElement = getTypeElement(ann);

            ClassAndPackageName classAndPackageName = ClassAndPackageName.from(typeElement, ann.getAnnotation(WithBuilder.class).suffix());

            Map<String, String> fieldsAndTheirTypes = ann.getEnclosedElements().stream()
                    .filter(e -> FIELD == e.getKind())
                    .collect(Collectors.toMap(e -> e.getSimpleName().toString(), e -> e.asType().toString()));
            try {
                writeFile(classAndPackageName, fieldsAndTheirTypes);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });

        return false;
    }

    private void writeFile(ClassAndPackageName classAndPackageName, Map<String, String> fieldsAndTheirTypes) throws IOException {
        final String builderName = classAndPackageName.getBuilderClassName();
        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderName);
        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {
            out.println("package " + classAndPackageName.getPackageName() + ";");
            out.println("public final class " + builderName + "{");

            writeInit(builderName, out);

            writeMutators(fieldsAndTheirTypes, builderName, out);

            withBuildMethod(classAndPackageName, fieldsAndTheirTypes.keySet(), out);

            writeConstructor(builderName, out);

            writeFields(fieldsAndTheirTypes, builderName, out);

            out.println("}");
        }
    }

    private void writeConstructor(String builderName, PrintWriter out) {
        out.println("private " + builderName + "(){};");
    }

    private void writeInit(String builderName, PrintWriter out) {
        out.println("public static "+ builderName + " newInstance() {");
        out.println("return new "+ builderName + "();");
        out.println("}");
    }

    private void withBuildMethod(ClassAndPackageName classAndPackageName, Collection<String> fields, PrintWriter out) {
        final String targetClassName = classAndPackageName.getClassName();
        out.println("public "+ targetClassName +" build() {");
        final String instance = "instance";
        out.println(targetClassName + " " + instance + " = new " + targetClassName +"();");
        for(String field: fields) {
            out.println(instance + ".set" + capitalize(field) + "(this."+field+");");
        }
        out.println("return " + instance + ";");
        out.println("}");
    }

    private void writeFields(Map<String, String> fieldsAndTheirTypes, String builderName, PrintWriter out) {
        for (Map.Entry<String, String> entry : fieldsAndTheirTypes.entrySet()) {
            out.println("private " + entry.getValue() + " " + entry.getKey() + ";");
        }
    }

    private void writeMutators(Map<String, String> fieldsAndTheirTypes, String builderName, PrintWriter out) {
        for (Map.Entry<String, String> entry : fieldsAndTheirTypes.entrySet()) {
            final String parameterType = entry.getValue();
            final String parameterName = entry.getKey();
            out.println("public " + builderName + " with" +
                    capitalize(parameterName) +
                    "(" + parameterType + " " + parameterName + "){");
            out.println("this." + parameterName + " = " + parameterName + ";");
            out.println("return this;");
            out.println("}");
        }
    }

    private String capitalize(String parameterName) {
        final String s = parameterName.substring(0, 1).toUpperCase() +
                parameterName.substring(1).toLowerCase();
        return s;
    }

    private TypeElement getTypeElement(Element ann) {
        TypeElement typeElement = ann.getEnclosedElements()
                .stream()
                .filter(e -> CONSTRUCTOR == e.getKind())
                .map(e -> e.getEnclosingElement())
                .map(e -> (TypeElement) e)
                .reduce((x, y) -> x)
                .orElseThrow(RuntimeException::new);
        return typeElement;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(WithBuilder.class.getName());
    }

    private void pm(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
    }
}
