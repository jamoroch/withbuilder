/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package co.xapuka.withbuilder;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static javax.lang.model.element.ElementKind.*;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.STATIC;

public class WithBuilderProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations == null || annotations.isEmpty()) {
            return false;
        }

        Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(WithBuilder.class);
        if(annotatedElements != null && !annotatedElements.isEmpty()) {
            printMessage("Processing WithBuilder...");
        }
        for(Element annotatedElement: annotatedElements) {
            final List<? extends Element> enclosedElements = annotatedElement.getEnclosedElements();

            Map<Boolean, List<Element>> partition = enclosedElements.stream().collect(Collectors.partitioningBy(this::isOnlyInstanceFields));
            Map<String, String> fieldsAndTheirTypes =
                    partition.get(true).stream().collect(Collectors.toMap(e -> e.getSimpleName().toString(), e -> e.asType().toString()));

            boolean didValidate = validateSetters(partition.get(false).stream(), fieldsAndTheirTypes, annotatedElement);

            if(!didValidate) {
                return true;
            }

            ClassAndPackageName classAndPackageName = extractClassAndPackageName(annotatedElement);
            if(classAndPackageName == null) {
                return printError("No default constructor found!", annotatedElement);
            }

            try {
                writeFile(classAndPackageName, fieldsAndTheirTypes);
            } catch (IOException e) {
                return printError(e.getMessage(), annotatedElement);
            };
        }
        return false;
    }

    private ClassAndPackageName extractClassAndPackageName(Element annotatedElement){

        TypeElement typeElement = getTypeElement(annotatedElement);
        if(typeElement == null) {
          return null;
        }

        return DefaultClassAndPackageName.from(typeElement, "Builder");
    }

    private boolean validateSetters(Stream<Element> noFields, Map<String, String> fieldsAndTheirTypes, Element annotatedElement) {
        List<Element> setters = noFields.collect(Collectors.partitioningBy(this::isOnlySetter)).get(true);

        Collection<String> onlyFieldNames = new ArrayList<>(fieldsAndTheirTypes.keySet());

        List<String> settersNames = setters.stream().map(Element::getSimpleName).map(Name::toString).collect(Collectors.toList());
        for (String fieldName: fieldsAndTheirTypes.keySet()) {
            String setterName = "set"+BuilderClassGenerator.capitalize(fieldName);

            if(settersNames.stream().filter(n -> n.equals(setterName)).count() != 0) {
                onlyFieldNames.remove(fieldName);
            }
        }
        onlyFieldNames.stream().forEach( n -> printError("No setter found for field " + n , annotatedElement));

        if(onlyFieldNames.size() != 0) {
            return false;
        }

        return true;
    }

    private  boolean isOnlySetter(Element element) {
        if(!(element instanceof ExecutableElement)) {
            return false;
        }
        ExecutableElement executableElement = (ExecutableElement) element;
        if(executableElement.getParameters().size() != 1) {
            return false;
        }
        if(executableElement.getReturnType().getKind() != TypeKind.VOID) {
            return false;
        }
        if(!executableElement.getSimpleName().toString().matches("^set.*")){
            return false;
        }
        return true;
    }

    private boolean isOnlyInstanceFields(Element e) {
        return (FIELD == e.getKind() ) &&
                e.getModifiers().stream().filter(m -> (FINAL == m || STATIC == m)).count() == 0;
    }

    private synchronized void writeFile(ClassAndPackageName classAndPackageName, Map<String, String> fieldsAndTheirTypes) throws IOException {

        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(classAndPackageName.getPackageName() + "." + classAndPackageName.getBuilderClassName());
        try (PrintWriter pw = new PrintWriter(builderFile.openWriter())) {
            BuilderClassGenerator generator = new BuilderClassGenerator(classAndPackageName, fieldsAndTheirTypes, pw);

            generator.writeInit();
            generator.writeMutators();
            generator.writeBuildMethod();
            generator.writePrivateDefaultConstructor();
            generator.writeFields();
            generator.writeEnd();
        }
    }


    private TypeElement getTypeElement(Element element) {
        TypeElement typeElement = element.getEnclosedElements()
                .stream()
                .filter(e -> CONSTRUCTOR == e.getKind())
                .map(e -> e.getEnclosingElement())
                .map(e -> (TypeElement) e)
                .reduce((x, y) -> x)
                .orElseGet(() -> null);
        return typeElement;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(WithBuilder.class.getName());
    }

    private void printMessage(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
    }

    private boolean printError(String message, Element element) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
        return true;
    }
}
